<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>SignalXpert – Demo Web Signals</title>
<style>
  :root{ --bg:#0f1724; --card:#0b1220; --accent:#00d1b2; --muted:#94a3b8; --danger:#ff6b6b }
  body{ margin:0; font-family:Inter,system-ui,Arial; background:linear-gradient(180deg,#071122 0%,#071826 100%); color:#e6eef6; }
  .wrap{ max-width:1100px; margin:28px auto; padding:16px; }
  header{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:18px;}
  h1{ font-size:20px; margin:0; letter-spacing:0.2px}
  .controls{ display:flex; gap:8px; align-items:center;}
  select,input[type=text],button{ padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit }
  button.primary{ background:var(--accent); color:#042024; border:none; font-weight:600 }
  main{ display:grid; grid-template-columns: 1fr 360px; gap:16px; }
  .card{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:12px; border-radius:12px; border:1px solid rgba(255,255,255,0.03) }
  #price { font-size:18px; font-weight:700; color:var(--accent) }
  .signal{ margin-top:12px; padding:12px; border-radius:10px; background:rgba(0,0,0,0.25) }
  .small{ color:var(--muted); font-size:13px }
  .row{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
  .stats{ display:flex; gap:8px; margin-top:12px; flex-wrap:wrap }
  .chip{ padding:6px 8px; border-radius:8px; background:rgba(255,255,255,0.03); font-size:13px }
  .history-list{ max-height:400px; overflow:auto; margin-top:8px; }
  .hist-item{ padding:8px; border-radius:8px; margin-bottom:8px; background:rgba(255,255,255,0.01); display:flex; justify-content:space-between; gap:8px; align-items:center }
  .green{ color:#6ee7b7 } .red{ color: #ff9b8a }
  footer{ margin-top:18px; font-size:13px; color:var(--muted) }
  @media(max-width:900px){ main{ grid-template-columns: 1fr; } }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>SignalXpert — Demo (Web)</h1>
        <div class="small">Live signals + local history. Upload this file to GitHub Pages to publish.</div>
      </div>
      <div class="controls">
        <label class="small">Pair</label>
        <select id="pairSelect">
          <option value="btcusdt">BTC/USDT</option>
          <option value="ethusdt">ETH/USDT</option>
          <option value="wavesusdt">WAVES/USDT</option>
          <option value="piusdt">PI/USDT</option>
          <option value="suiusdt">SUI/USDT</option>
        </select>
        <label class="small">Exchange</label>
        <select id="exchangeSelect">
          <option>Binance</option>
          <option>Bybit</option>
          <option>KuCoin</option>
        </select>
        <button id="subscribeBtn" class="primary">Subscribe</button>
      </div>
    </header>

    <main>
      <section>
        <div class="card">
          <div class="row">
            <div>
              <div id="pairTitle">BTC/USDT • Binance</div>
              <div id="price" style="margin-top:6px">—</div>
              <div class="small" id="priceTime">waiting for feed...</div>
            </div>
            <div style="text-align:right">
              <div class="small">Fear & Greed</div>
              <div id="fg" style="font-weight:700">—</div>
              <div style="height:8px"></div>
              <button id="genSignalBtn">Generate Signal</button>
            </div>
          </div>

          <div id="signalCard" class="signal" style="display:none">
            <div class="row">
              <div><strong id="sigDir">LONG</strong> <span id="sigPair" class="small"></span></div>
              <div><span class="small">Confidence</span> <strong id="sigConf">0</strong>%</div>
            </div>
            <div style="margin-top:8px">
              <div><span class="small">Entry:</span> <strong id="sigEntry"></strong></div>
              <div><span class="small">TPs:</span> <span id="sigTPs"></span></div>
              <div><span class="small">SL:</span> <span id="sigSL"></span></div>
            </div>
            <div class="stats">
              <div class="chip">AI: <span id="aiScore">-</span></div>
              <div class="chip">Tech: <span id="techScore">-</span></div>
              <div class="chip">SMC: <span id="smcScore">-</span></div>
              <div class="chip">Volatility: <span id="volScore">-</span></div>
            </div>
            <div style="margin-top:8px" class="small" id="sigExplain"></div>

            <div style="margin-top:10px" class="row">
              <button id="saveSigBtn">Save to History</button>
              <div class="small">Exchange rule: <span id="exchangeRule">multi-TP</span></div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div class="row">
            <div><strong>History</strong></div>
            <div class="small">Results count: <span id="histCount">0</span></div>
          </div>
          <div class="history-list" id="historyList"></div>
          <div style="margin-top:8px" class="row">
            <button id="clearHist">Clear History</button>
            <button id="exportJson">Export JSON</button>
          </div>
        </div>
      </section>

      <aside>
        <div class="card">
          <div><strong>Quick Stats</strong></div>
          <div style="margin-top:10px" class="small">Last 7 days</div>
          <div style="margin-top:6px">
            <div class="row"><div>Total trades</div><div id="statTotal">0</div></div>
            <div class="row"><div>Wins</div><div id="statWins">0</div></div>
            <div class="row"><div>Losses</div><div id="statLoss">0</div></div>
            <div class="row"><div>Win rate</div><div id="statWR">0%</div></div>
            <div class="row"><div>Total P/L (USDT)</div><div id="statPL">0.00</div></div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div><strong>Settings</strong></div>
          <div style="margin-top:8px" class="small">Risk % per trade</div>
          <input id="riskPct" type="text" value="1.5"/>
          <div style="margin-top:8px" class="small">SMC weight (0-100)</div>
          <input id="smcWeight" type="text" value="35"/>
          <div style="margin-top:8px" class="small">Binance mode (one TP)</div>
          <input id="binanceMode" type="checkbox"/>
        </div>

        <div class="card" style="margin-top:12px">
          <div><strong>Contact</strong></div>
          <div class="small" style="margin-top:8px">Khurram Irshad Khan</div>
          <div class="small">+92-3339719300 (WhatsApp)</div>
        </div>
      </aside>
    </main>

    <footer class="small">
      This is a demo. For private logic & production-grade AI, use a backend — keep your model & keys private.
    </footer>
  </div>

<script>
/*
  SignalXpert demo web app (single-file)
  - live price via Binance websocket
  - historical candles via CoinGecko for indicator calc
  - simple EMA/RSI/ATR/SMC & signal generation
  - localStorage history
*/

/* ---------------------
   Utilities & indicator helpers
   --------------------- */
function ema(values, period){
  if(values.length < period) return values[values.length-1] || 0;
  let k = 2/(period+1);
  let emaPrev = values.slice(0,period).reduce((a,b)=>a+b,0)/period;
  for(let i=period;i<values.length;i++){
    emaPrev = values[i]*k + emaPrev*(1-k);
  }
  return emaPrev;
}
function rsi(values, period=14){
  if(values.length <= period) return 50;
  let deltas=[]; for(let i=1;i<values.length;i++) deltas.push(values[i]-values[i-1]);
  let gains = deltas.slice(0,period).filter(v=>v>0).reduce((a,b)=>a+b,0)/period;
  let losses = deltas.slice(0,period).filter(v=>v<0).map(v=>-v).reduce((a,b)=>a+b,0)/period;
  let avgGain=gains, avgLoss=losses;
  for(let i=period;i<deltas.length;i++){
    let d=deltas[i];
    avgGain = (avgGain*(period-1) + (d>0?d:0))/period;
    avgLoss = (avgLoss*(period-1) + (d<0?-d:0))/period;
  }
  if(avgLoss===0) return 100;
  let rs=avgGain/avgLoss;
  return 100 - (100/(1+rs));
}
function atrFraction(candles, period=14){
  if(candles.length<=period) return 0.02;
  let trs=[];
  for(let i=1;i<candles.length;i++){
    const h=candles[i].h, l=candles[i].l, prev=candles[i-1].c;
    const tr = Math.max(h-l, Math.abs(h-prev), Math.abs(l-prev));
    trs.push(tr);
  }
  const atr = trs.slice(-period).reduce((a,b)=>a+b,0)/period;
  return atr / (candles[candles.length-1].c || 1);
}

/* ---------------------
   Simple SMC (heuristic)
   - swing highs/lows, BOS, naive OB finder
   --------------------- */
function detectSwings(candles){
  let highs=[], lows=[];
  for(let i=2;i<candles.length-2;i++){
    const h=candles[i].h, l=candles[i].l;
    if(h>candles[i-1].h && h>candles[i-2].h && h>candles[i+1].h && h>candles[i+2].h) highs.push(i);
    if(l<candles[i-1].l && l<candles[i-2].l && l<candles[i+1].l && l<candles[i+2].l) lows.push(i);
  }
  return {highs, lows};
}
function detectBOS(candles, highs, lows){
  if(highs.length===0||lows.length===0) return {bosBull:false,bosBear:false};
  const lastH = candles[highs[highs.length-1]].h;
  const lastL = candles[lows[lows.length-1]].l;
  const close = candles[candles.length-1].c;
  const buf=(lastH-lastL)*0.001;
  return {bosBull: close > lastH+buf, bosBear: close < lastL-buf};
}
function findOrderBlocks(candles){
  let obs=[];
  for(let i=candles.length-1;i>=2 && obs.length<6;i--){
    const cur=candles[i], prev=candles[i-1];
    if(prev.c>prev.o && cur.c<cur.o && cur.c<prev.c) obs.push({start:i-1,end:i,high:prev.h,low:prev.l,bullish:false});
    if(prev.c<prev.o && cur.c>cur.o && cur.c>prev.c) obs.push({start:i-1,end:i,high:prev.h,low:prev.l,bullish:true});
  }
  return obs;
}
function obTouchedRecently(candles, ob, lookback=50){
  const start=Math.max(0,candles.length-lookback);
  for(let i=start;i<candles.length;i++){
    const c=candles[i];
    if(c.l<=ob.high && c.h>=ob.low) return true;
  }
  return false;
}
function detectLiquiditySweep(candles, highs, lows){
  const n=candles.length;
  if(highs.length>0){
    const h=candles[highs[highs.length-1]].h;
    for(let i=Math.max(0,n-20);i<n;i++){
      const c=candles[i];
      if(c.h>h && c.c<h) return true;
    }
  }
  if(lows.length>0){
    const l=candles[lows[lows.length-1]].l;
    for(let i=Math.max(0,n-20);i<n;i++){
      const c=candles[i];
      if(c.l<l && c.c>l) return true;
    }
  }
  return false;
}
function scoreSMC(candles, rsi=null, macdHist=null){
  const {highs,lows}=detectSwings(candles);
  const {bosBull,bosBear}=detectBOS(candles,highs,lows);
  const obs=findOrderBlocks(candles);
  const validObs = obs.filter(o=>obTouchedRecently(candles,o));
  let score=50; let reasons=[];
  if(bosBull){ score+=25; reasons.push("BOS bullish") }
  if(bosBear){ score+=25; reasons.push("BOS bearish") }
  if(validObs.length) { score+=25; reasons.push("Valid OB") }
  if(detectLiquiditySweep(candles,highs,lows)){ score+=15; reasons.push("Liquidity sweep") }
  if(rsi!==null && rsi<30){ score+=5; reasons.push("RSI oversold") }
  if(macdHist!==null && macdHist>0){ score+=5; reasons.push("MACD confirm") }
  return {score: Math.max(0, Math.min(100, Math.round(score))), explanation: reasons.join("; ")};
}

/* ---------------------
   Helpers for UI, storage
   --------------------- */
const STORAGE_KEY = "sx_history_v1";
function saveSignalLocal(sig){
  const cur = JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
  cur.unshift(sig);
  localStorage.setItem(STORAGE_KEY, JSON.stringify(cur.slice(0,500)));
  renderHistory();
}
function loadHistory(){ return JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]"); }
function renderHistory(){
  const list = loadHistory();
  document.getElementById("histCount").innerText = list.length;
  const container=document.getElementById("historyList"); container.innerHTML="";
  list.forEach((s,idx)=>{
    const div=document.createElement("div"); div.className="hist-item";
    div.innerHTML = `<div>
        <div><strong>${s.pair}</strong> <span class="small">${new Date(s.ts).toLocaleString()}</span></div>
        <div class="small">${s.direction} • Conf ${s.confidence}%</div>
      </div>
      <div style="text-align:right;">
        <div><strong>${s.entry.toFixed(6)}</strong></div>
        <div class="small">${s.result||"open"}</div>
      </div>`;
    container.appendChild(div);
  });
  updateStats();
}
function exportJson(){ const data = loadHistory(); const blob = new Blob([JSON.stringify(data,null,2)],{type:"application/json"}); const url=URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download="signals_history.json"; a.click(); }

/* ---------------------
   Fetch historical candles (CoinGecko) — returns array of {t,o,h,l,c,v}
   Note: CoinGecko returns prices only; we reconstruct OHLC from minute buckets (approx).
   For production, use backend to pull Binance klines.
   --------------------- */
async function fetchCandlesCoinGecko(pair, days=1){
  // map pair to coin id
  const map = {btcusdt:"bitcoin", ethusdt:"ethereum", wavesusdt:"waves", piusdt:"pi-network", suiusdt:"sui"};
  const coin = map[pair.toLowerCase()] || "bitcoin";
  try{
    const url = `https://api.coingecko.com/api/v3/coins/${coin}/market_chart?vs_currency=usd&days=${days}`;
    const r = await fetch(url);
    const j = await r.json();
    // j.prices = [ [ts, price], ... ]  (ts in ms)
    const res = [];
    const prices = j.prices || [];
    // make synthetic candles from every Nth price to form OHLC windows
    const windowSize = Math.max(1, Math.floor(prices.length/200)); // ~200 bars
    for(let i=0;i<prices.length;i+=windowSize){
      const slice = prices.slice(i,i+windowSize);
      if(slice.length===0) continue;
      const open = slice[0][1];
      const close = slice[slice.length-1][1];
      const high = Math.max(...slice.map(x=>x[1]));
      const low = Math.min(...slice.map(x=>x[1]));
      const t = slice[0][0];
      res.push({t, o:open, h:high, l:low, c:close, v:0});
    }
    return res;
  }catch(e){
    console.error("cg err",e);
    return [];
  }
}

/* ---------------------
  Live price via Binance WebSocket (trade stream)
  --------------------- */
let ws=null;
function connectWS(symbol){
  if(ws) try{ ws.close(); }catch(e){}
  const stream = `${symbol.toLowerCase()}@trade`;
  const url = `wss://stream.binance.com:9443/ws/${stream}`;
  ws = new WebSocket(url);
  ws.onopen = ()=> { console.log("ws open", url); document.getElementById("priceTime").innerText = "connected"; };
  ws.onmessage = (ev)=>{
    try{
      const obj = JSON.parse(ev.data);
      const p = parseFloat(obj.p);
      const ts = obj.E || Date.now();
      document.getElementById("price").innerText = p.toFixed(6);
      document.getElementById("priceTime").innerText = new Date(ts).toLocaleTimeString();
      window.latestPrice = p;
    }catch(e){ console.error(e) }
  }
  ws.onclose = ()=>{ console.log("ws closed"); document.getElementById("priceTime").innerText="ws closed"; }
  ws.onerror = (e)=>{ console.error("ws err",e); document.getElementById("priceTime").innerText="ws error"; }
}

/* ---------------------
   Simple signal generator using the building blocks
   --------------------- */
async function generateSignal(pair, exchange){
  // 1. fetch candles (CoinGecko approx)
  const candles = await fetchCandlesCoinGecko(pair, 2);
  if(!candles.length){
    alert("No candles available (CoinGecko down). Try again later.");
    return null;
  }
  // compute closes
  const closes = candles.map(c=>c.c);
  const emaShort = ema(closes, 12);
  const emaLong = ema(closes, 26);
  const rsiVal = rsi(closes, 14);
  const atrF = atrFraction(candles, 14);
  // naive macd hist proxy:
  const macdHist = emaShort - emaLong;
  const smc = scoreSMC(candles, rsiVal, macdHist);

  // tech score
  let tech = 50;
  tech += (emaShort>emaLong ? 12 : -8);
  tech += (macdHist>0 ? 10 : -8);
  tech += (rsiVal<30 ? 6 : (rsiVal>70 ? -6 : 0));
  const volRatio = 1.0; // no volume from CG; ignore for now
  if(volRatio>1.3) tech+=8;
  tech = Math.max(0, Math.min(100, Math.round(tech)));

  // ai score — placeholder (randomish) OR you can plug external endpoint here
  const aiScore =  Math.max(40, Math.min(95, Math.round( (tech*0.6 + smc.score*0.35) + (Math.random()*10-5) )));

  // final confidence
  const smcWeight = parseFloat(document.getElementById("smcWeight").value || "35")/100;
  const aiCombined = Math.round( tech*(1-smcWeight) + smc.score*smcWeight );
  const confidence = Math.round( (aiScore*0.6 + aiCombined*0.4) );

  // decide direction
  const direction = (smc.bosBull || (macdHist>0 && emaShort>emaLong)) ? "LONG" : "SHORT";

  // entry price use live if available
  const entry = (window.latestPrice && Math.abs(window.latestPrice - candles[candles.length-1].c) < (candles[candles.length-1].c*0.05)) ? window.latestPrice : candles[candles.length-1].c;

  // create tps based on ATR fraction (volatility)
  const baseStep = atrF < 0.01 ? 0.004 : (atrF < 0.02 ? 0.006 : 0.01);
  const tps = [];
  for(let i=1;i<=4;i++){
    tps.push( direction==="LONG" ? entry * (1 + i*baseStep) : entry * (1 - i*baseStep) );
  }

  // stoploss
  const slFactor = atrF < 0.01 ? 0.012 : (atrF < 0.02 ? 0.02 : 0.035);
  const sl = direction==="LONG" ? entry * (1 - slFactor) : entry * (1 + slFactor);

  // exchange rules: Binance -> only TP1
  const binMode = document.getElementById("binanceMode").checked || exchange.toLowerCase()==="binance";
  const outTPs = binMode ? [tps[0]] : tps;

  const sig = {
    pair: pair.toUpperCase(),
    exchange,
    direction,
    entry: Number(entry),
    tp: outTPs.map(x=>Number(x)),
    sl: Number(sl),
    ai_score: aiScore,
    tech_score: tech,
    smc_score: smc.score,
    confidence,
    explanation: `SMC: ${smc.explanation}; EMA${emaShort>emaLong? " bullish":""}; RSI:${rsiVal.toFixed(1)}; ATRf:${atrF.toFixed(4)}`,
    ts: Date.now()
  };
  return sig;
}

/* ---------------------
   UI wiring
   --------------------- */
document.getElementById("subscribeBtn").addEventListener("click", ()=>{
  const p = document.getElementById("pairSelect").value;
  const exch = document.getElementById("exchangeSelect").value;
  document.getElementById("pairTitle").innerText = `${p.toUpperCase()} • ${exch}`;
  connectWS(p);
  document.getElementById("exchangeRule").innerText = (exch.toLowerCase()==="binance" ? "binance(1TP)" : "multi-TP");
});

document.getElementById("genSignalBtn").addEventListener("click", async ()=>{
  const p=document.getElementById("pairSelect").value;
  const exch=document.getElementById("exchangeSelect").value;
  document.getElementById("genSignalBtn").innerText = "Generating...";
  const sig = await generateSignal(p, exch);
  document.getElementById("genSignalBtn").innerText = "Generate Signal";
  if(!sig){ alert("Failed to create signal"); return; }
  // show
  document.getElementById("signalCard").style.display="block";
  document.getElementById("sigDir").innerText = sig.direction;
  document.getElementById("sigPair").innerText = sig.pair;
  document.getElementById("sigEntry").innerText = sig.entry.toFixed(6);
  document.getElementById("sigTPs").innerText = sig.tp.map(x=>x.toFixed(6)).join(" , ");
  document.getElementById("sigSL").innerText = sig.sl.toFixed(6);
  document.getElementById("aiScore").innerText = sig.ai_score;
  document.getElementById("techScore").innerText = sig.tech_score;
  document.getElementById("smcScore").innerText = sig.smc_score;
  document.getElementById("sigConf").innerText = sig.confidence;
  document.getElementById("sigExplain").innerText = sig.explanation;
  // save preview temporarily to window so save button can use it
  window.previewSignal = sig;
});

document.getElementById("saveSigBtn").addEventListener("click", ()=>{
  if(!window.previewSignal){ alert("No signal to save"); return; }
  saveSignalLocal(window.previewSignal);
  alert("Saved to local history");
});

document.getElementById("clearHist").addEventListener("click", ()=>{
  if(confirm("Clear local history?")){ localStorage.removeItem(STORAGE_KEY); renderHistory(); }
});
document.getElementById("exportJson").addEventListener("click", exportJson);

/* ---------------------
   Stats calculation
   --------------------- */
function updateStats(){
  const hist = loadHistory();
  const now = Date.now();
  const oneWeek = now - 7*24*60*60*1000;
  const filtered = hist.filter(h=>h.ts>=oneWeek);
  const total = filtered.length;
  const wins = filtered.filter(s=>s.result==="win").length;
  const losses = filtered.filter(s=>s.result==="loss").length;
  const wr = total? Math.round((wins/total)*100):0;
  const totalPL = filtered.reduce((acc,s)=> acc + (s.pl_usdt || 0), 0);
  document.getElementById("statTotal").innerText = total;
  document.getElementById("statWins").innerText = wins;
  document.getElementById("statLoss").innerText = losses;
  document.getElementById("statWR").innerText = wr + "%";
  document.getElementById("statPL").innerText = totalPL.toFixed(2);
}

/* ---------------------
  init
  --------------------- */
(function init(){
  renderHistory();
  // initial subscribe to BTC
  connectWS('btcusdt');
  // fetch fear & greed (alternative.me)
  fetch('https://api.alternative.me/fng/?limit=1')
    .then(r=>r.json()).then(j=>{
      const val = j.data && j.data[0] && j.data[0].value ? j.data[0].value : "-";
      document.getElementById("fg").innerText = val;
    }).catch(()=>{ document.getElementById("fg").innerText = "n/a"; });
})();
</script>
</body>
</html>
